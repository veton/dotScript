# dotScript

[![CircleCI](https://img.shields.io/circleci/project/github/veton/dotScript.svg)](https://circleci.com/gh/veton/dotScript)
[![NuGet](https://img.shields.io/nuget/v/dotScript.svg)](https://www.nuget.org/packages/dotScript)
[![npm](https://img.shields.io/npm/v/dotscript.svg)](https://www.npmjs.com/package/dotscript)
[![Gitter](https://img.shields.io/gitter/room/dot-script/Lobby.svg)](https://gitter.im/dot-script/Lobby)

**dotScript** is a tool which generates **TypeScript** Data and Service Contracts from **.NET** assemblies.

### Input:
```csharp
public class Person
{
    public long Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}
```

### Output:
```typescript
export class Person {
    public id: number;
    public name: string;
    public email: string;
}
```

Implemented in PowerShell, so can be used in both Windows and Linux environments when run under [PowerShell 6+](https://github.com/PowerShell/PowerShell/releases).

There is a bunch of similar tools around.
Key points of **dotScript** are:
* IDE-agnostic *[command line tool](#Command-Line-Interface)*
* *cross-platform*
* support of both *Data Model* and *Service Contracts*
* wide [support](#Features) of .NET *member types*
* implemented in *scripting language*, so is easy to tune

## Usage
Having dotScript as a command-line tool allows a variety of use cases, including integration into Visual Studio build through post-build events, running on a build server, generating contracts for thirdparty assemblies and anything in between.

To install the tool, use .NET Core CLI, Nuget or npm:
```batch
dotnet add package dotScript
nuget install dotScript
npm install dotscript
```

### Command Line Interface
Assuming you have PowerShell 6+ installed under your PATH, you should be able to call a tool as follows:

```batch
PwSh <Path to Tool>/index.ps1 `
    -AssemblyPath "<Path to input .NET assembly>" `
    -ScriptPath "<Path to output TypeScript file>" `
    -KnownAssemblies <Assembly Name>, ...
    -IncludeTypes <Included Type>, ...
    -ExcludeTypes ,Exclude Types>, ...
```
Where parameters are:
| Parameter       | Description |
|-----------------|---|
| AssemblyPath    | Path of assembly to generate model from. |
| ScriptPath      | Path of file to write TypeScript model to. |
| KnownAssemblies | [Optional] If referenced .NET type is located in a known assembly, it will be imported.<br/>Otherwise it will be referenced as 'any' in TypeSctipt. |
| IncludeTypes    | [Optional] Wildcard of type names to be included.<br/>If not specidfied - all types will be included. |
| ExcludeTypes    | [Optional] Wildcard of type names to be excluded. |

### Example:
```batch
dotnet new classlib -n Demo
cd Demo
dotnet add package dotScript --version 1.0.5 --package-directory ./Packages
dotnet build

PwSh ./Packages/dotscript/1.0.5/tools/index.ps1 ./bin/Debug/netstandard2.0/Demo.dll ./bin/Debug/netstandard2.0/Demo.ts
```

## Features
### Supported
* Classes, Interfaces, Structs, Enums
* Instance, Static, Readonly, Abstract Members
* Referenced Assemblies
* Generic Types
* Async Methods (converted to Observables)

### Not Supported Yet
* Namespaces
* Nested Types


## Samples
Samples below show *C#* code used to generate input *.NET* assembly, and corresponding *TypeScript* code generated by **dotScript**.
More examples can be found in [test cases](test/test-cases).

### Member Types & Modifiers
```csharp
public abstract class TestClass
{
    public readonly string ReadOnlyField;
    public string ReadWriteField;
    public static string StaticField;

    public static string StaticProperty { get; }
    public string ReadOnlyProperty { get; }
    public string WriteOnlyProperty { set { } }
    public string ReadWriteProperty { get; set; }
    public abstract string AbstractProperty { get; set; }
}
```
```typescript
export abstract class TestClass {
    public readonly readOnlyField: string;
    public readWriteField: string;
    public static staticField: string;

    public static readonly staticProperty: string;
    public readonly readOnlyProperty: string;
    public writeOnlyProperty: string;
    public readWriteProperty: string;
    public abstract abstractProperty: string;
}
```

### Return Types
```csharp
public class TestClass
{
    public Byte ByteProperty { get; set; }
    public Int32 Int32Property { get; set; }
    public Decimal DecimalProperty { get; set; }
    public Double DoubleProperty { get; set; }
    public int? NullableProperty { get; set; }

    public Boolean BooleanProperty { get; set; }
    public Char CharProperty { get; set; }
    public String StringProperty { get; set; }
    public DateTime DateTimeProperty { get; set; }

    public IEnumerable CollectionProperty { get; set; }
    public IEnumerable<string> GenericCollectionProperty { get; set; }

    public TimeSpan TimeSpanProperty { get; set; }
    public Object ObjectProperty { get; set; }
    public dynamic DynamicProperty { get; set; }
}
```
```typescript
export class TestClass {
    public byteProperty: number;
    public int32Property: number;
    public decimalProperty: number;
    public doubleProperty: number;
    public nullableProperty: number;

    public booleanProperty: boolean;
    public charProperty: string;
    public stringProperty: string;
    public dateTimeProperty: Date;

    public collectionProperty: any[];
    public genericCollectionProperty: string[];

    public timeSpanProperty: any;
    public objectProperty: any;
    public dynamicProperty: any;
}
```

### Async Service Contracts
```csharp
public interface IAsyncInterface
{
    Task VoidMethodAsync();
    Task<string> MethodAsync();
    void MethodWithAsyncParams(Task<string> param1);
}
```
```typescript
import { Observable } from 'rxjs';

export interface IAsyncInterface {
    voidMethodAsync(): Observable<any>;
    methodAsync(): Observable<string>;
    methodWithAsyncParams(param1: Observable<string>): void;
}
```

### Known Assemblies
```csharp
using TestSolution.ReferencedAssembly;

namespace TestSolution.TestAssembly
{
    public class GenericClass<T1> : GenericBaseClass<string, IGenericInterface<T1>>, IGenericInterface<T1>
    {
        public GenericBaseClass<string, IGenericInterface<T1>> Property1 { get; set; }
        public IGenericInterface<T1> Property2 { get; set; }
    }
}
```
```typescript
import { GenericBaseClass } from 'TestSolution.ReferencedAssembly';
import { IGenericInterface } from 'TestSolution.ReferencedAssembly';

export class GenericClass<T1> extends GenericBaseClass<string, IGenericInterface<T1>> implements IGenericInterface<T1> {
    public property1: GenericBaseClass<string, IGenericInterface<T1>>;
    public property2: IGenericInterface<T1>;
}
```
